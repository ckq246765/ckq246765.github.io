{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"clickhouse","slug":"clickhouse","date":"2021-04-06T14:57:51.000Z","updated":"2021-04-06T14:58:24.439Z","comments":true,"path":"2021/04/06/clickhouse/","link":"","permalink":"http://example.com/2021/04/06/clickhouse/","excerpt":"","text":"clickHouse学习笔记：(OLAP) kylin impla -&gt; hive preto&lt; ck 不适用HDFS存储数据 集成HDFS MYSQL MPP 架构，简单相互独立 DBMS系统 数据库 表 SQL 列式存储 实现语言 C++,高效 处理速度快 横向扩展 高可用 安装 安装curl工具 123456789101112yum install -y curl测试：curl www.baidu.com&#96;&#96;&#96; &#96;&#96;&#96; shell刷访问量：my.sh#!&#x2F;usr&#x2F;bin&#x2F;env bash while [ true ] do #statements curl http:&#x2F;&#x2F;myblog.com sleep 20 done 添加clickHouse 的 yum 镜像 1curl -s https://packagecloud.io/install/repositories/altinity/clickhouse/script.rpm.sh | sudo bash 检查镜像情况1234# yum镜像配置：./etc/yum.repos.d#有两个 clickhouse-server clickhouse-clientyum list | grep clickhouse 安装 clickhouse 服务端和客户端1yum install -y clickhouse-server clickhouse-client 启动服务 daunt1service clickhouse-server start 启动客户端1234567clickhouse-client#支持多行SQL查询:clickhouse-client -m# 支持查询clickhouse-client -query=&#x27;select * from tab_name&#x27;# 支持多行statement执行clickhouse-client -n -q &#x27;user db_name; select * form table_name&#x27; 引擎 数据库引擎： 不同的引擎决定不同的数据库类型 MySql lazy MaterializeMySQL 表引擎(新建表时候必须要指定表引擎)： 引擎决定数据的存储位置，数据存储格式，表特征，修改结构，并发操作 ODBC JDBC Kafka HDFS MySql …… 123create database is not exists db_test;use db_test;create table tab_test(id Int32,name String,age UInt8)engine=Memory(); 数据类型 数值类型 Int8 Int16 Int32 Int64 UInt8 UInt16 UInt32 UInt64 Float32(float) Float64(double) Decimal32(S) =&gt; (Decimal(1~9,S)) -110^(9-S) 到 110^(9-S) Decimal64(S) =&gt; (Decimal(10~18,S)) -110^(18-S) 到 110^(18-S) Decimal128(S) =&gt; (Decimal(19~38,S)) -110^(38-S) 到 110^(38-S) 字符串类型 String FiedString 数组类型(强数据类型) array(T) [1,2,3] toTypeName() 查看数据类型 arr[1] 索引下标从 1 开始 arrayMap(e-&gt;concat(e,’abc’),arr) 拼接’abc’ 字符串的时候不能用”” 只能用’’ Enum 枚举类型 Enum8(‘name’=1,’age’=2) Enum16() 元组（下标从1开始） Tuple(T1,T2,T3) Nullable(Int8) Array(Nullable(Int8)) 嵌套类型 Nested(id Int8, name String) 其实底层表示为：长度一致的ia array(Int8),name array(String) 域 Ipv4 ip格式数据，插入数据时验证 Ipv6 Decimal Decimal32(S) - ( -1 * 10^(9 - S),1*10^(9-S) ) Decimal64(S) - ( -1 * 10^(18 - S),1*10^(18-S) ) Decimal128(S) - ( -1 * 10^(38 - S),1*10^(38-S) ) clickhouse语法： 数据库引擎： Ordinary:默认存储引擎 MaterializeMySQL: 同步MySQL的数据，自动拉取远端Mysql的数据，创建myswl引擎的数据库表 Memory：内存引擎，存放零时数据，服务重启，数据消失 Dictionary:字典引擎，自动为所有数据字典创建他们的数据表 Lazy: 日志引擎，数据库只能使用Log表引擎 Mysql: 可以在mysql中crud,在ck中同步更新；在ck中可以查询和插入；ck不能删除表；ck不能创建表；ck不能删除更新数据；123456789CREATE DATABASE [IF NOT EXISTS] DB_NAME [ON CLUSTER cluster]ENGINE = MYSQL(&#x27;host:port&#x27;,[&#x27;database&#x27; | database],&#x27;user&#x27;,password);CREATE DATABASE DB_TEST ENGINE=Memory();SHOW databases;use DB_TEST;select currentDatabases();SHOW tables;CREATE table tab_test(id Int8)engine=Memory;desc tab_name; 表引擎 MergeTree: Log：日志，适合数据少，测试使用，属于本地表，本地存储数据 var/lib/clickhouse/data/… 分数据块，可以多线程处理 TinyLog: *.bin：每个字段的压缩数据，数据插入时，追加写数据 sizes.json：每个字段文件的大小 .mrk：数据块标记 MarkRange index：索引文件 没有数据库块，不能并行，不能同时读写（不能并发；即不分数据块），没有索引 StripeLog: ……建表语句：1234567891011121314151617181920212223242526272829 #方式一： create table [if not exists] [db_name.]table_name ( name1 [type] [default|materialized|alias expr], name2 [type] [default|materialized|alias expr], ......)ENGINE=engine;#方式二：create table new_tab_name as old_tab_name;#方式三：create table [if not exists] [db_name.]table_name ENGINE=engine as select * from old_tab_name;#删除表：drop table [if existst] [db_name.]table_name ;#创建临时表：级别高于普通表（即相同的表名，会优先使用临时表），不属于任何数据库，不需要指定引擎；会话断开后会删除表，不会持久化；create temporary table tab_name( name1 [type] [default|materialized|alias expr], name2 [type] [default|materialized|alias expr], ......); ``` ### 视图：&gt; - 普通视图：只是一层简单的查询代理 1. 不会存储数据，也不会提高效率，不能持久化，没有表结构 - 物化视图：拥有独立的存储 1. 存在表结构，需要引擎，可以持久化 2. 实时监控表的数据变化，更新其数据 3. 表结构和映射的表机构一致 ``` SQL create materialized view view_name ENGINE=engine [populate] as select * from source_tab_name; # populate:实时同步数据 分区表（合并树引擎才支持：MergeTree）12345678910111213create table [if not exists] [db_name.]table_name ( name1 [type] [default|materialized|alias expr], name2 [type] [default|materialized|alias expr], ......)ENGINE=enginepartition by name1order by name1primary key name1;# partition by toYYYYMM(time_col) 表示：更具年月分区# primary key name1; 注意并不是唯一的#手动合并分区：执行一次只能合并一个分区OPTIMIZE TABLE tb_partition; DDL语句（仅支持表引擎： MergeTree Merge Distributed）12345678910111213#添加字段：alter table tab_name add column col_name type;#删除字段alter table tab_name drop column col_name;#修改字段类型(不能修改主键和排序字段)alter table tab_name modify column[if exists] name [type][default expr];#修改字段注释alter table tab_name comment column col_name &#x27;注释&#x27;;#移动表：rename table [db_name1.]tb_name11 to [db_name2.]tb_name12,[db_name1.]tb_name21 to [db_name2.]tb_name22,.....rename table t1 to new_db.t1; --将当前数据库表移动到另一个数据库中show tables from new_db; --查看指定数据库中表rename table t2 to new_db.t_2; --移动表并且修改表的名称 TTL语句（设置超时时间自动删除） 列：当列的时间超过设置的值时，一整列的数据会被删除 表：当表中的某一行的时间超过设置的值时，整行会被删除 分区表DDL12345678910111213141516171819 #创建分区表：create table if not exists par_tab_test ( id UInt32, name String)ENGINE=MergeTree()partition by nameorder by id;#查看分区：select *,table,partition from system.parts where table=&#x27;par_tab_test&#x27;;#删除分区：alter table par_tab_test drop partition &#x27;partition_name&#x27;;#复制分区数据：alter table par_tab_test replace partition partition_name from source_par_tab_name;#重置分区中某个字段的数据：(不能重置主键和分区字段):alter table tb_name clear column col_name in partition partition_name;#卸载分区(放到detached中):alter table tab_name detach partition partition_name;#装载分区:alter table tab_name attach partition partition_name; DML语句1234567891011#插入数据：1. insert into tab_name (col) values(v1);2. insert into tab_name select * from source_tab_name;3. create table .... as select * from source_tab_name;4. clickhouse-client -q &#x27;insert into table_name FORMAT CSV&#x27; &lt; ./data.csv4. clickhouse-client --format_csv_delimiter=&#x27;|&#x27; -q &#x27;insert into table_name FORMAT CSV&#x27; &lt; ./data.csv4. cat ./data.csv | -q &#x27;insert into table_name FORMAT CSV&#x27; &lt; ./data.csv#删除数据：(MergeTree)alter table tab_name delete where col=&#x27;&#x27;;#更新数据：(MergeTree)alter table tab_name update col=&#x27;&#x27; where col=&#x27;&#x27;; 表引擎 Log() MergeTree():（只有该引擎可以支持表结构修改，支持分区表） *.bin：各字段二进制压缩数据 *.mark:标记对应的 *.bin的数据(块)偏移量 primary.inx 主键索引（稀疏索引） checksums.txt 校验文件，校验数据的正确性和完整性 columns.txt 当前所有字段，每个分区都有 count.txt 当前分区中所有数据的行数 partition.dat min_max_*.inx 分区信息和分区中最小和最大数据（范围） 支持并发 支持索引 支持分区 支持mutation 分区规则： partition by() partition by(toYYYYMM()) partition by(length()) ReplacingMergeTree():会删除具有相同（区内）主键的重复项，数据的去重只会在合并的过程中出现 Replacing MergeTree([ver_col]):保留指定数据的版本 CollapsingMergeTree([sign]):相同分区折叠，删除或更新分区内数据 ，表中的数据按照排序字段升序排序，合并时，排序相同的数据会被剔除：然后，在更具sign做折叠 sign:1 属于标记 -1 表示折叠 1 -1 1 更新 1 -1 删除 -1 1 1 不操作 1 1 -1 1 折叠会删除中间的两个数据 VersionCollapsingMergeTree([sign],[version]):如果排序字段一样，更具version字段折叠数据 SummingMergeTree([column])：根据排序主键字段，指定column字段求和，插入数据会实现聚合操作，分区决定了聚合范围 AggregatingMergeTree()：聚合引擎 money AggregateFunction(sum,Int32)：建表, sumState(money)：插入|查询 name AggregateFunction(uniq,Int32)：建表, uniqState(name)：插入|查询123456789101112131415161718192021 #明细表 create table tab_name( id Int32, city String, money Int, name String)ENGINE=MergeTree()order by id; #聚合表 create table tab_name( id Int32, city String, money AggregateFunction(sum,Int32), name AggregateFunction(uniq,String))ENGINE=AggregatingMergeTree()order by id; #分组查询插入聚合表： insert into tab_name select city ,uniqState(name),sumState(money) from tab_name group by city; #聚合表：修改为 物化视图 #可以实现，在对明细表插入数据时 population |或者合并时，做聚合 HDFS:HDFS(path,format):加载hdfs存储的数据，ck中不存储数据，读取处理数据，处理分析 path,format：path：文件路径 format：文件数据格式 如果是指定单个文件路径时，在文件不存在允许 insert into 表数据一次，且会创建该文件 单个文件路径 多个文件路径 文件范围 MYSQL：MySQL(‘host:port’,’database’,’table’,’user’,’password’); 不存储数据，操作的数据，只存储在mysql的表中 可以插入和查询数据（且实时同步mysql表的数据），不支持更新和删除 可以建立物化视图，同步mysql的数据：简单做一个分布式的查询 mysql创建表 ck创建表：指定NYSQL引擎 建立物化视图，指定ck表的数据； FILE：读取本地文件的数据 File(CSV) 默认是会去加载该表路径下的 data.csv 文件 可以向表插入数据（必须对该文件有写权限） 挂载本地数据表：1.创建对应表路径文件 2. 创建表 JDBC KAFKA","categories":[],"tags":[]},{"title":"git将本地项目关联到远程仓库","slug":"git将本地项目关联到远程仓库","date":"2021-03-10T14:31:44.000Z","updated":"2021-03-10T15:56:04.283Z","comments":true,"path":"2021/03/10/git将本地项目关联到远程仓库/","link":"","permalink":"http://example.com/2021/03/10/git%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E5%85%B3%E8%81%94%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/","excerpt":"","text":"git将本地项目关联到远程仓库本地项目根目录执行12345678910111213 git init ``` ## 关联到远程仓库``` java git remote add origin url ``` ## 提交``` java git add . git commit -m &quot;提交&quot; git push -u origin master git拉取及提交 我们切换分支时候，两个分支项目会不统一，（例如：当前在主分支，子分支项目未同步完全主分支项目，此时由主切子分支就会报如下错误）当前分支有未跟踪的文件，checkout 命令会覆盖它们，此时报错如果问价很重要，放到暂存区git add .git stash切换分支之后git stash pop 拉取主干项目git clone url拉取用户名和密码的项目git clone http://username:password@remote 拉取分支项目（例如 develop分支项目）git clone -b develop url 新建分支git branch 分支名称 查看所有分支git branch -a 切换到某一分支git checkout 分支名称 添加修改代码到缓存git add . 添加提交代码备注git commit -m “备注” 提交到指定分支git push origin 分支名称 远程代码不需要，覆盖远程代码git push origin master -f git pull :命令用于从另一个存储库或本地分支获取并集成(整合).作用:取回远程主机某个分支的更新,再与本地的指定分支合并使用语法:git pull [options][][..]git fetch: 相当于是从远程获取最新版本到本地，不会自动合并 将本地分支连接到远程分支git remote add origin url","categories":[{"name":"start","slug":"start","permalink":"http://example.com/categories/start/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"Markdown基本语法","slug":"Markdown基本语法","date":"2021-03-07T06:43:41.000Z","updated":"2021-03-07T15:26:22.269Z","comments":true,"path":"2021/03/07/Markdown基本语法/","link":"","permalink":"http://example.com/2021/03/07/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"","text":"标题设置标题只需要#+空格表示 我是一级标题我是二级标题我是三级标题我是四级标题我是五级标题我是六级标题123# 一级标题## 二级标题### 三级标题 Markdownd段落段落使用两个以上空格+enter段落二 字体斜体文字斜体文字粗体文字粗体文字斜粗体文字斜粗体文字 123456*斜体文字* _斜体文字_ **粗体文字** __粗体文字__ ***斜粗体文字*** ___斜粗体文字___ 分割线 12345**** * ***************- - ------------------------------ 删除线在文字的两端加上两个~~ 我是删除线 下划线使用HTML的标签&lt;u&gt;&lt;/u&gt;实现 我有下划线 1&lt;u&gt;我有下划线&lt;/u&gt; 脚注脚注格式^要标注的文本 12脚注格式[^要标注的文本] [^要标注的文本]:你说我是谁 Markdowd列表Markdown支持有序和无序列表无序列表使用星号（*）、加号（+）、减号（-）作为标记，后面要添加空格 第一 第二 第三 我是一 我是二 我是三 我是第一 我是第二 我是第三 1234567891011* 第一* 第二* 第三+ 我是一+ 我是二+ 我是三- 我是第一- 我是第二- 我是第三 有序列表使用数字并加上.号来表示 ，后面+空格 我是第一 我是第二 我是第三 1231. 我是第一2. 我是第二3. 我是第三 列表嵌套 我是第一项 第一 第二 我是第二项 我是第一 我是第二 1234561. 我是第一项 - 第一 - 第二2. 我是第二项 + 我是第一 + 我是第二 Markdown区块区块显示在开头使用&gt;符号，后面+空格 区块应用 我是小白 我是菜鸟 123&gt; 区块应用 &gt; 我是小白 &gt; 我是菜鸟 区块嵌套，最外层使用一个&gt;符号，第一层使用&gt;&gt;符号，依次内推 我是最外层 我是第一层 我是第三层 123&gt; 我是最外层 &gt;&gt; 我是第一层 &gt;&gt;&gt; 我是第三层 区块中使用列表 区块中使用列表 第一 第二 第一项 第二项 12345&gt; 区块中使用列表&gt; 1. 第一&gt; 2. 第二&gt; - 第一项&gt; + 第二项 列表中使用区块 我是第一项 第一 第二 我是第二项 第一 第二 1234567+ 我是第一项 &gt; 第一 &gt;&gt; 第二 + 我是第二项 &gt; 第一 &gt;&gt; 第二 Markdown代码段落上的一个函数或代码片段可以使用(`) 我是一个函数print(&quot;hello world&quot;) 代码区块四个空格或者是四个制表符Tab键 class Test&#123; private String test; public void test()&#123;&#125; &#125; 还可以```包裹一段代码 1234class Test&#123; private String test; public void test()&#123;&#125;&#125; Markdown链接链接的使用方法我的博客或者https://ckq246765.github.io 123[我的博客](https://ckq246765.github.io)或者&lt;https://ckq246765.github.io&gt; 高级链接通过变量来设置一个链接，变量赋值在文档末尾进行链接作为网址变量MyBlog 12链接作为网址变量[MyBlog][1][1]:https://ckq246765.github.io Markdown图片使用&lt;![]()标注图片 &lt;![图片未加载显示汉字](链接地址 &quot;图片title&quot;)Markdown还没有办法指定图片的高度和宽度，如果需要可以使用&lt;img src=&quot;&quot; width=&quot;&quot; height=&quot;&quot;&gt;&lt;/img&gt;标签 我的头像我的大头 123456![alt 属性文本](https://gagekeqi.oss-cn-beijing.aliyuncs.com/gagekeqiFavicon.jpg?versionId=CAEQDRiBgMDW_IyUvhciIDkxM2QxZjFmMTEyNjQ2YWRiNDRmOTg0ZDA5ZWIwZjQ0 &quot;我的大头&quot;) 我的头像[我的大头][myBlog] [myBlog]:https://gagekeqi.oss-cn-beijing.aliyuncs.com/gagekeqiFavicon.jpg?versionId=CAEQDRiBgMDW_IyUvhciIDkxM2QxZjFmMTEyNjQ2YWRiNDRmOTg0ZDA5ZWIwZjQ0&lt;img src=&quot;https://gagekeqi.oss-cn-beijing.aliyuncs.com/gagekeqiFavicon.jpg?versionId=CAEQDRiBgMDW_IyUvhciIDkxM2QxZjFmMTEyNjQ2YWRiNDRmOTg0ZDA5ZWIwZjQ0&quot; width=&quot;200&quot; height=&quot;200&quot;&gt; Markdown表格markdown制作表格使用|来分隔不同的列，使用-来分隔表头 第一行第一列 第一行第二列 第二行第一列 第二行第二列 对齐方式: -::设置内容和标题右对齐显示 :-:设置内容和标题左对齐显示 :-::设置内容和标题居中显示 123| 第一行第一列 | 第一行第二列 | | ------------| ----------- || 第二行第一列 | 第二行第二列 |","categories":[{"name":"start","slug":"start","permalink":"http://example.com/categories/start/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-02-16T10:21:59.127Z","updated":"2021-02-16T10:21:59.142Z","comments":true,"path":"2021/02/16/hello-world/","link":"","permalink":"http://example.com/2021/02/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"start","slug":"start","permalink":"http://example.com/categories/start/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"}]}